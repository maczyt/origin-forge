{"mappings":"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","sources":["src/index.ts","package.json","src/helper.ts"],"sourcesContent":["import cac from \"cac\";\nimport ora from \"ora\";\nimport pkg from \"../package.json\";\nimport { create } from \"./helper\";\nimport path from \"path\";\n\nconst cli = cac(\"of\");\n\ncli\n  .command(\"new <libraryName>\", \"create a library.\")\n  .action(async (libraryName: string) => {\n    console.log(\"libraryName\", libraryName);\n    const spinner = ora(\"start new library\").start();\n\n    await create({\n      dest: path.join(process.cwd(), libraryName),\n      data: {\n        libraryName,\n      },\n      onProgress(msg, isOk) {\n        spinner.color = isOk ? \"green\" : \"blue\";\n        spinner.text = msg;\n      },\n    });\n    spinner.succeed(\"Successful\");\n  });\n\ncli.help();\ncli.version(pkg.version);\ncli.parse();\n","{\n  \"name\": \"origin-forge\",\n  \"version\": \"1.0.2\",\n  \"description\": \"creating a library scaffold generator\",\n  \"source\": \"src/index.ts\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/module.js\",\n  \"types\": \"dist/types.d.ts\",\n  \"bin\": {\n    \"of\": \"./bin/index.js\"\n  },\n  \"scripts\": {\n    \"watch\": \"parcel watch\",\n    \"build\": \"parcel build --no-cache && node scripts/build.js\"\n  },\n  \"keywords\": [\n    \"cli\",\n    \"library generate cli\"\n  ],\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/maczyt/origin-forge.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/maczyt/origin-forge/issues\"\n  },\n  \"homepage\": \"https://github.com/maczyt/origin-forge\",\n  \"dependencies\": {\n    \"cac\": \"^6.7.14\",\n    \"fs-extra\": \"^11.2.0\",\n    \"handlebars\": \"^4.7.8\",\n    \"memfs\": \"^4.9.1\",\n    \"ora\": \"5.4.1\",\n    \"resolve-global\": \"1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@parcel/packager-ts\": \"2.12.0\",\n    \"@parcel/transformer-typescript-types\": \"2.12.0\",\n    \"@types/fs-extra\": \"^11.0.4\",\n    \"@types/node\": \"^20.12.7\",\n    \"parcel\": \"^2.12.0\",\n    \"typescript\": \">=3.0.0\"\n  }\n}\n","import { vol } from \"memfs\";\nimport fs from \"fs-extra\";\nimport { Transform } from \"stream\";\nimport type { IDirent } from \"memfs/lib/node/types/misc\";\nimport path from \"path\";\nimport { compile } from \"handlebars\";\nconst resolveGlobal = require(\"resolve-global\");\n\nconst templatePath = path.resolve(\n  resolveGlobal(\"origin-forge\"),\n  \"../../templates\"\n);\nconst mkdirRecursive = async (target: string) => {\n  try {\n    await vol.promises.mkdir(target, { recursive: true });\n  } catch (error) {}\n};\nasync function copy(from: string, to: string, data: any) {\n  await mkdirRecursive(to);\n  const entries = await (fs.promises.readdir(from, {\n    withFileTypes: true,\n  }) as unknown as Promise<IDirent[]>);\n  for (const entry of entries) {\n    const name = entry.name.toString();\n    const sourcePath = path.join(from, name);\n    const targetPath = path.join(to, name);\n    if (entry.isDirectory()) {\n      await copy(sourcePath, targetPath, data);\n    } else {\n      await copyFile(sourcePath, targetPath, data);\n    }\n  }\n}\n\nasync function copyFile(source: string, target: string, data: any) {\n  const read = fs.createReadStream(source);\n  class RenderDataTransform extends Transform {\n    _transform(chunk: any, _: any, callback: any) {\n      const content = chunk.toString();\n      const template = compile(content);\n      const result = template(data || {});\n      this.push(result);\n      callback();\n    }\n  }\n\n  const write = vol.createWriteStream(target);\n  await new Promise((resolve) => {\n    read.pipe(new RenderDataTransform()).pipe(write);\n    write.once(\"finish\", resolve);\n  });\n}\n\nexport const copyDir = async (temp: string, data: any) => {\n  await copy(path.join(templatePath, \"library\"), temp, data);\n};\n\nexport const writeToDisk = async (temp: string, dest: string) => {\n  async function copy(from: string, to: string) {\n    await mkdirRecursive(to);\n    const entries = await (vol.promises.readdir(from, {\n      withFileTypes: true,\n    }) as unknown as Promise<IDirent[]>);\n    for (const entry of entries) {\n      const name = entry.name.toString();\n      const sourcePath = path.join(from, name);\n      const targetPath = path.join(to, name);\n      if (entry.isDirectory()) {\n        await copy(sourcePath, targetPath);\n      } else {\n        await copyFile(sourcePath, targetPath);\n      }\n    }\n  }\n\n  async function copyFile(source: string, target: string) {\n    const read = vol.createReadStream(source);\n    const write = fs.createWriteStream(target);\n    if (!fs.existsSync(target)) {\n      await fs.createFileSync(target);\n    }\n    await new Promise((resolve) => {\n      read.pipe(write);\n      write.once(\"finish\", resolve);\n    });\n  }\n  await copy(temp, dest);\n};\n\nexport const create = async (options: {\n  dest: string;\n  data: any;\n  onProgress?: (msg: string, isOk?: boolean) => void;\n}) => {\n  const { dest, onProgress, data } = options;\n  const temp = \"temp\";\n  onProgress?.(\"start copy and render template\");\n  await copyDir(temp, data);\n  onProgress?.(\"copy and render template successfully\", true);\n  onProgress?.(\"start generating\", true);\n  await writeToDisk(temp, dest);\n  onProgress?.(\"generating successfully\", true);\n};\n"],"names":[],"version":3,"file":"index.js.map"}